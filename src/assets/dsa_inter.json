{
    "questions": [
        {
            "question": "Singly Linked List 1: Insert a node at the beginning of a singly linked list.",
            "explanation": "This question requires inserting a node at the beginning of a singly linked list.",
            "input": "The value to be inserted.",
            "output": "The updated singly linked list.",
            "cpp": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nNode* insertAtBeginning(Node* head, int value) {\n    Node* newNode = new Node;\n    newNode->data = value;\n    newNode->next = head;\n    return newNode;\n}\n```",
            "java": "```java\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    Node insertAtBeginning(Node head, int value) {\n        Node newNode = new Node(value);\n        newNode.next = head;\n        return newNode;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef insert_at_beginning(head, value):\n    new_node = Node(value)\n    new_node.next = head\n    return new_node\n```",
            "explanation_code": "The code inserts a new node with the given value at the beginning of the singly linked list. It creates a new node, assigns the given value to its `data` field, and updates its `next` pointer to point to the current head. Finally, it returns the new node as the new head of the list."
        },
        {
            "question": "Singly Linked List 2: Insert a node at the end of a singly linked list.",
            "explanation": "This question requires inserting a node at the end of a singly linked list.",
            "input": "The value to be inserted.",
            "output": "The updated singly linked list.",
            "cpp": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nNode* insertAtEnd(Node* head, int value) {\n    Node* newNode = new Node;\n    newNode->data = value;\n    newNode->next = nullptr;\n\n    if (head == nullptr)\n        return newNode;\n\n    Node* curr = head;\n    while (curr->next != nullptr)\n        curr = curr->next;\n\n    curr->next = newNode;\n    return head;\n}\n```",
            "java": "```java\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    Node insertAtEnd(Node head, int value) {\n        Node newNode = new Node(value);\n\n        if (head == null)\n            return newNode;\n\n        Node curr = head;\n        while (curr.next != null)\n            curr = curr.next;\n\n        curr.next = newNode;\n        return head;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef insert_at_end(head, value):\n    new_node = Node(value)\n\n    if head is None:\n        return new_node\n\n    curr = head\n    while curr.next is not None:\n        curr = curr.next\n\n    curr.next = new_node\n    return head\n```",
            "explanation_code": "The code inserts a new node with the given value at the end of the singly linked list. It creates a new node, assigns the given value to its `data` field, and sets its `next` pointer to `nullptr` (or `null` in Java). If the list is empty (i.e., `head` is `nullptr` or `null`), the new node becomes the head. Otherwise, it traverses to the end of the list using a `while` loop and appends the new node as the last element."
        },
        {
            "question": "Singly Linked List 3: Delete the first occurrence of a node with a given value from a singly linked list.",
            "explanation": "This question requires deleting the first occurrence of a node with a given value from a singly linked list.",
            "input": "The value to be deleted.",
            "output": "The updated singly linked list.",
            "cpp": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nNode* deleteNode(Node* head, int value) {\n    if (head == nullptr)\n        return head;\n\n    if (head->data == value) {\n        Node* temp = head;\n        head = head->next;\n        delete temp;\n        return head;\n    }\n\n    Node* curr = head;\n    while (curr->next != nullptr) {\n        if (curr->next->data == value) {\n            Node* temp = curr->next;\n            curr->next = curr->next->next;\n            delete temp;\n            return head;\n        }\n        curr = curr->next;\n    }\n\n    return head;\n}\n```",
            "java": "```java\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    Node deleteNode(Node head, int value) {\n        if (head == null)\n            return head;\n\n        if (head.data == value) {\n            Node temp = head;\n            head = head.next;\n            temp.next = null;\n            return head;\n        }\n\n        Node curr = head;\n        while (curr.next != null) {\n            if (curr.next.data == value) {\n                Node temp = curr.next;\n                curr.next = curr.next.next;\n                temp.next = null;\n                return head;\n            }\n            curr = curr.next;\n        }\n\n        return head;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef delete_node(head, value):\n    if head is None:\n        return head\n\n    if head.data == value:\n        temp = head\n        head = head.next\n        temp.next = None\n        return head\n\n    curr = head\n    while curr.next is not None:\n        if curr.next.data == value:\n            temp = curr.next\n            curr.next = curr.next.next\n            temp.next = None\n            return head\n        curr = curr.next\n\n    return head\n```",
            "explanation_code": "The code deletes the first occurrence of a node with the given value from the singly linked list. It handles two special cases: if the first node contains the value, it updates the head to the next node and deletes the old head, and if the list is empty, it returns the current head. Otherwise, it traverses the list using a `while` loop and checks if the next node's value matches the given value. If found, it rearranges the pointers to skip the node to be deleted and then deletes it using `delete` (or `null` assignment in Java)."
        },
        {
            "question": "Singly Linked List 4: Find the length of a singly linked list.",
            "explanation": "This question requires finding the length of a singly linked list.",
            "input": "The head of the linked list.",
            "output": "The length of the linked list.",
            "cpp": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nint getLength(Node* head) {\n    int length = 0;\n    Node* curr = head;\n    while (curr != nullptr) {\n        length++;\n        curr = curr->next;\n    }\n    return length;\n}\n```",
            "java": "```java\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    int getLength(Node head) {\n        int length = 0;\n        Node curr = head;\n        while (curr != null) {\n            length++;\n            curr = curr.next;\n        }\n        return length;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef get_length(head):\n    length = 0\n    curr = head\n    while curr is not None:\n        length += 1\n        curr = curr.next\n    return length\n```",
            "explanation_code": "The code calculates the length of the singly linked list by traversing the list and incrementing a counter (`length`) for each node encountered. It starts with the head node and updates the current node (`curr`) to the next node until it reaches the end of the list (i.e., `nullptr` or `null` in Java). Finally, it returns the length of the list."
        },
        {
            "question": "Singly Linked List 5: Insert a node at a specified position in a singly linked list.",
            "explanation": "This question requires inserting a node at a specified position in a singly linked list.",
            "input": "The value and position at which to insert.",
            "output": "The updated singly linked list.",
            "cpp": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nNode* insertAtPosition(Node* head, int value, int position) {\n    Node* newNode = new Node;\n    newNode->data = value;\n\n    if (position == 1) {\n        newNode->next = head;\n        return newNode;\n    }\n\n    Node* curr = head;\n    int currentPosition = 1;\n\n    while (currentPosition < position - 1 && curr != nullptr) {\n        curr = curr->next;\n        currentPosition++;\n    }\n\n    if (curr == nullptr)\n        return head;\n\n    newNode->next = curr->next;\n    curr->next = newNode;\n    return head;\n}\n```",
            "java": "```java\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    Node insertAtPosition(Node head, int value, int position) {\n        Node newNode = new Node(value);\n\n        if (position == 1) {\n            newNode.next = head;\n            return newNode;\n        }\n\n        Node curr = head;\n        int currentPosition = 1;\n\n        while (currentPosition < position - 1 && curr != null) {\n            curr = curr.next;\n            currentPosition++;\n        }\n\n        if (curr == null)\n            return head;\n\n        newNode.next = curr.next;\n        curr.next = newNode;\n        return head;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef insert_at_position(head, value, position):\n    new_node = Node(value)\n\n    if position == 1:\n        new_node.next = head\n        return new_node\n\n    curr = head\n    current_position = 1\n\n    while current_position < position - 1 and curr is not None:\n        curr = curr.next\n        current_position += 1\n\n    if curr is None:\n        return head\n\n    new_node.next = curr.next\n    curr.next = new_node\n    return head\n```",
            "explanation_code": "The code inserts a new node with the given value at the specified position in the singly linked list. If the position is 1, the new node becomes the head of the list. Otherwise, it traverses the list using a `while` loop until reaching the node before the specified position. If the position is out of range (i.e., the traversal reaches the end of the list), the original list is returned. Otherwise, the new node's `next` pointer is set to the current node's `next` pointer, and the current node's `next` pointer is updated to point to the new node."
        },
        {
            "question": "Singly Linked List 6: Delete a node at a specified position in a singly linked list.",
            "explanation": "This question requires deleting a node at a specified position in a singly linked list.",
            "input": "The position of the node to be deleted.",
            "output": "The updated singly linked list.",
            "cpp": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nNode* deleteAtPosition(Node* head, int position) {\n    if (head == nullptr)\n        return head;\n\n    if (position == 1) {\n        Node* temp = head;\n        head = head->next;\n        delete temp;\n        return head;\n    }\n\n    Node* curr = head;\n    int currentPosition = 1;\n\n    while (currentPosition < position - 1 && curr->next != nullptr) {\n        curr = curr->next;\n        currentPosition++;\n    }\n\n    if (curr->next == nullptr)\n        return head;\n\n    Node* temp = curr->next;\n    curr->next = curr->next->next;\n    delete temp;\n    return head;\n}\n```",
            "java": "```java\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    Node deleteAtPosition(Node head, int position) {\n        if (head == null)\n            return head;\n\n        if (position == 1) {\n            Node temp = head;\n            head = head.next;\n            temp.next = null;\n            return head;\n        }\n\n        Node curr = head;\n        int currentPosition = 1;\n\n        while (currentPosition < position - 1 && curr.next != null) {\n            curr = curr.next;\n            currentPosition++;\n        }\n\n        if (curr.next == null)\n            return head;\n\n        Node temp = curr.next;\n        curr.next = curr.next.next;\n        temp.next = null;\n        return head;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef delete_at_position(head, position):\n    if head is None:\n        return head\n\n    if position == 1:\n        temp = head\n        head = head.next\n        temp.next = None\n        return head\n\n    curr = head\n    current_position = 1\n\n    while current_position < position - 1 and curr.next is not None:\n        curr = curr.next\n        current_position += 1\n\n    if curr.next is None:\n        return head\n\n    temp = curr.next\n    curr.next = curr.next.next\n    temp.next = None\n    return head\n```",
            "explanation_code": "The code deletes the node at the specified position in the singly linked list. It handles two special cases: if the position is 1, it updates the head to the next node and deletes the old head, and if the list is empty, it returns the current head. Otherwise, it traverses the list using a `while` loop until reaching the node before the specified position. If the position is out of range (i.e., the traversal reaches the end of the list), the original list is returned. Otherwise, it rearranges the pointers to skip the node to be deleted and then deletes it using `delete` (or `null` assignment in Java)."
        },
        {
            "question": "Singly Linked List 7: Reverse a singly linked list iteratively.",
            "explanation": "This question requires reversing a singly linked list iteratively.",
            "input": "The head of the linked list.",
            "output": "The reversed singly linked list.",
            "cpp": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nNode* reverseList(Node* head) {\n    Node* prev = nullptr;\n    Node* curr = head;\n\n    while (curr != nullptr) {\n        Node* nextNode = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n\n    return prev;\n}\n```",
            "java": "```java\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    Node reverseList(Node head) {\n        Node prev = null;\n        Node curr = head;\n\n        while (curr != null) {\n            Node nextNode = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextNode;\n        }\n\n        return prev;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef reverse_list(head):\n    prev = None\n    curr = head\n\n    while curr is not None:\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n\n    return prev\n```",
            "explanation_code": "The code reverses the order of the nodes in the singly linked list iteratively. It uses three pointers: `prev` to keep track of the previous node, `curr` to keep track of the current node being processed, and `nextNode` to store the next node before modifying the `next` pointer of the current node. It starts by setting `prev` to `nullptr` (or `null` in Java) and `curr` to the head of the list. Then, in each iteration, it updates the `next` pointer of the current node to point to the previous node, advances the pointers to the next nodes, and continues until the end of the list is reached. Finally, it returns the new head of the reversed list."
        },
        {
            "question": "Singly Linked List 8: Check if a singly linked list is a palindrome.",
            "explanation": "This question requires checking if a singly linked list is a palindrome.",
            "input": "The head of the linked list.",
            "output": "A boolean value indicating whether the linked list is a palindrome or not.",
            "cpp": "```cpp\n#include <iostream>\n#include <stack>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nbool isPalindrome(Node* head) {\n    if (head == nullptr || head->next == nullptr)\n        return true;\n\n    Node* slow = head;\n    Node* fast = head;\n    std::stack<int> stack;\n\n    while (fast != nullptr && fast->next != nullptr) {\n        stack.push(slow->data);\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    if (fast != nullptr)\n        slow = slow->next;\n\n    while (slow != nullptr) {\n        int top = stack.top();\n        stack.pop();\n\n        if (slow->data != top)\n            return false;\n\n        slow = slow->next;\n    }\n\n    return true;\n}\n```",
            "java": "```java\nimport java.util.Stack;\n\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    boolean isPalindrome(Node head) {\n        if (head == null || head.next == null)\n            return true;\n\n        Node slow = head;\n        Node fast = head;\n        Stack<Integer> stack = new Stack<>();\n\n        while (fast != null && fast.next != null) {\n            stack.push(slow.data);\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        if (fast != null)\n            slow = slow.next;\n\n        while (slow != null) {\n            int top = stack.pop();\n\n            if (slow.data != top)\n                return false;\n\n            slow = slow.next;\n        }\n\n        return true;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef is_palindrome(head):\n    if head is None or head.next is None:\n        return True\n\n    slow = head\n    fast = head\n    stack = []\n\n    while fast is not None and fast.next is not None:\n        stack.append(slow.data)\n        slow = slow.next\n        fast = fast.next.next\n\n    if fast is not None:\n        slow = slow.next\n\n    while slow is not None:\n        top = stack.pop()\n\n        if slow.data != top:\n            return False\n\n        slow = slow.next\n\n    return True\n```",
            "explanation_code": "The code checks if the singly linked list is a palindrome by using a slow and fast pointer approach along with a stack. It first checks for edge cases where the list is empty or has only one node, in which case it is considered a palindrome. Then, it initializes the `slow` and `fast` pointers to the head of the list and creates an empty stack. The fast pointer moves twice as fast as the slow pointer while pushing the values of the slow pointer into the stack. When the fast pointer reaches the end of the list (or one node before the end for odd-length lists), the slow pointer is adjusted accordingly. Then, it compares the remaining values in the list with the popped values from the stack. If any mismatch occurs, it returns false. Otherwise, it returns true if all values match."
        },
        {
            "question": "Singly Linked List 9: Merge two sorted singly linked lists into a single sorted list.",
            "explanation": "This question requires merging two sorted singly linked lists into a single sorted list.",
            "input": "The heads of the two sorted linked lists.",
            "output": "The head of the merged sorted linked list.",
            "cpp": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nNode* mergeSortedLists(Node* head1, Node* head2) {\n    if (head1 == nullptr)\n        return head2;\n\n    if (head2 == nullptr)\n        return head1;\n\n    Node* mergedHead;\n    Node* tail;\n\n    if (head1->data <= head2->data) {\n        mergedHead = head1;\n        tail = head1;\n        head1 = head1->next;\n    } else {\n        mergedHead = head2;\n        tail = head2;\n        head2 = head2->next;\n    }\n\n    while (head1 != nullptr && head2 != nullptr) {\n        if (head1->data <= head2->data) {\n            tail->next = head1;\n            tail = head1;\n            head1 = head1->next;\n        } else {\n            tail->next = head2;\n            tail = head2;\n            head2 = head2->next;\n        }\n    }\n\n    if (head1 != nullptr)\n        tail->next = head1;\n\n    if (head2 != nullptr)\n        tail->next = head2;\n\n    return mergedHead;\n}\n```",
            "java": "```java\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    Node mergeSortedLists(Node head1, Node head2) {\n        if (head1 == null)\n            return head2;\n\n        if (head2 == null)\n            return head1;\n\n        Node mergedHead;\n        Node tail;\n\n        if (head1.data <= head2.data) {\n            mergedHead = head1;\n            tail = head1;\n            head1 = head1.next;\n        } else {\n            mergedHead = head2;\n            tail = head2;\n            head2 = head2.next;\n        }\n\n        while (head1 != null && head2 != null) {\n            if (head1.data <= head2.data) {\n                tail.next = head1;\n                tail = head1;\n                head1 = head1.next;\n            } else {\n                tail.next = head2;\n                tail = head2;\n                head2 = head2.next;\n            }\n        }\n\n        if (head1 != null)\n            tail.next = head1;\n\n        if (head2 != null)\n            tail.next = head2;\n\n        return mergedHead;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef merge_sorted_lists(head1, head2):\n    if head1 is None:\n        return head2\n\n    if head2 is None:\n        return head1\n\n    merged_head = None\n    tail = None\n\n    if head1.data <= head2.data:\n        merged_head = head1\n        tail = head1\n        head1 = head1.next\n    else:\n        merged_head = head2\n        tail = head2\n        head2 = head2.next\n\n    while head1 is not None and head2 is not None:\n        if head1.data <= head2.data:\n            tail.next = head1\n            tail = head1\n            head1 = head1.next\n        else:\n            tail.next = head2\n            tail = head2\n            head2 = head2.next\n\n    if head1 is not None:\n        tail.next = head1\n\n    if head2 is not None:\n        tail.next = head2\n\n    return merged_head\n```",
            "explanation_code": "The code merges two sorted singly linked lists into a single sorted list. It first handles the edge cases where either of the lists"
        },
        {
            "question": "Singly Linked List 10: Find the middle node of a singly linked list.",
            "explanation": "This question requires finding the middle node of a singly linked list.",
            "input": "The head of the linked list.",
            "output": "The middle node of the linked list.",
            "cpp": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nNode* findMiddleNode(Node* head) {\n    if (head == nullptr)\n        return nullptr;\n\n    Node* slow = head;\n    Node* fast = head;\n\n    while (fast != nullptr && fast->next != nullptr) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    return slow;\n}\n```",
            "java": "```java\npublic class LinkedList {\n    class Node {\n        int data;\n        Node next;\n\n        Node(int value) {\n            data = value;\n            next = null;\n        }\n    }\n\n    Node findMiddleNode(Node head) {\n        if (head == null)\n            return null;\n\n        Node slow = head;\n        Node fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return slow;\n    }\n}\n```",
            "python": "```python\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n\ndef find_middle_node(head):\n    if head is None:\n        return None\n\n    slow = head\n    fast = head\n\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n\n    return slow\n```",
            "explanation_code": "The code finds the middle node of the singly linked list using the slow and fast pointer technique. It starts by handling the edge case where the list is empty and returns `nullptr` (or `null` in Java) in that case. Then, it initializes the `slow` and `fast` pointers to the head of the list. The `slow` pointer moves one step at a time, while the `fast` pointer moves two steps at a time. This ensures that when the `fast` pointer reaches the end of the list, the `slow` pointer will be at the middle node. The `while` loop continues until either the `fast` pointer or its `next` pointer becomes `nullptr`, indicating the end of the list. Finally, it returns the `slow` pointer as the middle node."
        }
    ]
}